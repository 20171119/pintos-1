Pintos 13: 버퍼 캐시
=========================================
2013011037 류형욱

## 1. 과제의 목표 및 요구사항
블록 장치 입출력 작업에 버퍼 캐시를 사용하도록 만듭니다.

## 2. 문제를 해결하기 위한 Pintos 분석 내용
- 버퍼를 사용하지 않으며, 요청을 다음 저수준 계층으로 바로 전달합니다.
- file-inode-block-하드웨어의 계층 구조로 설계되어 있습니다.
- inode와 block 사이에 적절한 작업을 추가하여, 블록 버퍼링을 구현할 수 있습니다.

## 3. 해결 과정
1. 섹터 번호, 사용 여부, clock, 더러움 여부와 같은 버퍼 캐시에 관련된 메타 데이터를 저장하기 위한 구조를 설계합니다. 실습 자료의 buffer_head에 기반을 두었습니다.
1. 캐시 버퍼 초기화, 캐시 관리 정보 초기화 기능을 구현합니다.
1. 캐시를 탐색하여 히트와 미스를 판단하고, 미스일 경우 clock 알고리즘에 의하여 캐시를 교체하도록 입출력을 구현합니다.
1. 버퍼 캐시 시스템이 종료될 때는 더러운 캐시를 안전하게 저장하도록 합니다.
1. 파일 시스템의 초기화 및 종료 코드에 버퍼 캐시 초기화 및 종료 함수 호출 코드를 삽입합니다.
1. inode 관련 코드가 block 입출력 작업을 수행하는 부분이 새로 만든 버퍼를 사용하도록 합니다. 스크래치 공간이나 스왑 공간 입출력은 여기에서 관여하지 않습니다.
1. 락을 적절하게 사용하여 여러 입출력 작업이 동시에 안전하게 수행되도록 합니다.
1. Pintos 문서에서는 읽기 작업을 수행할 때 다음 블록까지 읽기를 시도하는 read-ahead를 요구하지만, 구현하지 않았습니다.
1. 실습 자료에서는 버퍼를 최초에 동적으로 할당할 것을 암시하고 있으나, 정적인 구현에서 큰 문제가 발생하지 않아 그대로 두었습니다.

## 4. 결과
- userprog, threads 테스트는 가상 메모리 코드 분리를 완전하게 하지 않아, 빌드에 실패하거나 테스트에 실패합니다.
- vm의 모든 테스트는 여전히 통과합니다.
- filesys에서 155개 테스트 중 extended로 표시된 44개 테스트에 실패하며, 몇 개의 extended 테스트와 모든 일반 테스트를 통과합니다. tar를 사용하는 테스트에서 커널 패닉 루프에 걸린 것처럼 보이지만, 기다리면 다음 테스트가 계속 진행됩니다. filesys 테스트는 vm을 사용하도록 설정한 상태에서 수행하였습니다.

## 5. 참조
운영체제 및 시스템 프로그래밍 실습 자료와 Pintos 문서를 참조하였습니다.