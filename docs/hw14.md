Pintos 14: 파일 확장
=========================================
2013011037 류형욱

## 1. 과제의 목표 및 요구사항
파일의 크기가 블럭 하나 크기 이상으로, 또한 동적으로 확장될 수 있도록 합니다.
결과적으로 파일을 만들 때 크기를 정해야만 하고 변경할 수 없었던 제약을 제거합니다.

## 2. 문제를 해결하기 위한 Pintos 분석 내용
- 프로젝트 13 이후의 파일 시스템은 파일-아이노드-버퍼 캐시-블럭 장치-하드웨어의 계층 구조로 되어 있습니다. 호출 함수를 bc로 시작하는 것으로 변경한 것을 제외하면, 버퍼 캐시는 거의 투명하게 구현되었습니다.
- 실제 데이터의 위치 정보를 시작 섹터 번호와 길이로 나타내고 있습니다.
- 파일의 크기와 데이터가 있는 섹터 번호는 아이노드 계층에서 관리합니다. 블럭 단위로 파일이 할당 크기를 확장하려면 아이노드 내부 구현을 변경하는 것이 바람직할 것입니다.

## 3. 해결 과정
1. 메모리 아이노드(in-memory)와 디스크 아이노드(on-disk) 구조체를 수정합니다. 시작 섹터 번호와 길이로 표시되던 실제 데이터의 위치 정보를, 불연속적인 섹터 번호가 저장된 여러 계층의 테이블로 변경합니다. 메모리 아이노드와 디스크 아이노드의 구분이 더 분명하게 되도록 변경합니다.
1. 테이블 계층은 디스크 아이노드의 여유 공간에 직접 섹터 번호를 나열하는 direct_map_table, 한 단계 떨어진 별도 섹터에 섹터 번호를 나열하는 indirect_block_sec, 두 단계 떨어진 별도 섹터에 섹터 번호를 나열하는 double_indirect_block_sec 순서로 사용합니다. direct_map_table을 제외한 나머지 테이블은 처음부터 할당되지 않으며, 아이노드의 크기가 확장되면서 반드시 필요할 때만 섹터 단위로 할당됩니다.
1. 한 단계 이상의 테이블을 쉽게 다룰 수 있도록 블럭 크기와 일치하는 구조체 struct inode_indirect_block를 정의합니다.
1. 아이노드의 특정 위치가 어떤 계층의 테이블에 있는지, 또 그 테이블에서 어떤 위치에 있는지를 묶어서 다룰 수 있도록 구조체 struct sector_location를 정의합니다. 테이블 계층 구분은 열거형 enum direct_t으로 합니다.
1. 여러 쓰레드가 경쟁적으로 아이노드 하나에 접근하는 상황이 우려됩니다. 락 extend_lock를 메모리 아이노드에 추가합니다.
1. byte_to_sector 함수는 파일 시작에서부터 바이트 단위로 잰 위치를 입력받고, 테이블에 의하여 섹터 번호로 변환합니다.
1. locate_byte 함수는 파일 시작에서부터 블럭 단위로 잰 위치를 입력받고, 어떤 테이블의 어떤 위치에서 찾을 수 있는지를 반환합니다.
1. register_sector 함수는 주어진 테이블 유형의 주어진 위치에, 주어진 섹터 번호를 씁니다.
1. inode_update_file_length 함수는 파일의 이전 크기와 새로운 크기를 입력받아, 추가되어야 할 블럭을 추가합니다. 앞에서 설명한 여러 함수를 사용합니다.
1. free_inode_sectors 함수는 아이노드에 연관된 블럭들을 모두 해제합니다.
1. inode_length 함수에 변경 사항을 반영하여 이전과 같기 동작되도록 합니다.
1. get_disk_inode 함수는 디스크 아이노트 읽기를 위한 간단한 도움 함수입니다.
1. inode_read_at 함수와 inode_write_at 함수가 디스크 아이노드를 사용하도록 변경합니다. 앞에서 설명한 여러 함수를 사용하여 실제 섹터 번호를 얻을 수 있게 만들면, 원래 구현을 적은 변경으로 사용할 수 있게 됩니다. 또한 적절하게 동기화합니다.
1. grow-dir-lg 테스트는 현재 구현되지 않은 mkdir 시스템 콜을 사용합니다. 임시적으로 해당 테스트만 통과할 수 있도록 하기 위하여, 구현되지 않은 시스템 콜에 대하여 사용자 프로세스를 강제 종료하도록 되어 있던 원래 구현을, 단순히 무시하는 것으로 변경합니다. 이 변경 이후 grow-dir-lg 테스트를 통과하게 됩니다.

## 4. 결과
- userprog, threads 테스트는 가상 메모리 코드 분리를 완전하게 하지 않아, 빌드에 실패하거나 테스트에 실패합니다.
- vm의 모든 테스트를 여전히 통과합니다.
- filesys에서 실습 자료의 지정 테스트를 모두 통과하며, 전체 155개 테스트 중 33개 테스트에 실패합니다. persistence 테스트는 모두 실패하며, 통과할 것으로 예상되지 않았던 일부 dir 테스트를 통과합니다.

## 5. 참조
운영체제 및 시스템 프로그래밍 실습 자료와 Pintos 문서를 참조하였습니다.