Pintos 6: 알람 시스템 콜
=========================================
2013011037 류형욱

## 1. 과제의 목표 및 요구사항
바쁜 대기로 구현된 void timer_sleep (int64_t ticks)이 바쁜 대기를 사용하지 않도록 변경합니다.

## 2. 문제를 해결하기 위한 Pintos 분석 내용
- timer_sleep이 바쁜 대기로 구현되어 있습니다.
- timer_sleep이 원래 호출하던 thread_yield 함수는 현재 스레드를 실행 중 상태로 유지하면서, 대기 스레드 리스트의 가장 마지막에 현재 스레드를 넣고 스케줄링을 수행합니다.
- thread_block 함수는 현재 스레드를 블록하고, 스케줄링을 수행합니다. 실행 흐름은 다른 대기 중이던 스레드로 변경될 것입니다. 대기 중인 스레드 목록에는 적어도 idle 스레드가 항상 존재합니다.
- thread_unblock 함수는 블록된 상태인 스레드를 대기 상태로 변경합니다. 스케줄링을 즉시 수행하지는 않습니다.
- timer_interrupt는 타이머 인터럽트 핸들러이며, 이 함수의 호출을 기준으로 운영체제 틱이 계산됩니다. 틱을 하나 증가하고, thread_tick 함수를 호출합니다.
- thread_tick 함수는 timer_interrupt와 함께, 매 틱 주기가 시작될 때 호출됩니다. 스레드가 사용한 틱의 수 통계를 작성하며, 선점 스케줄링의 선점을 수행합니다. 상수 TIME_SLICE 설정에 따라, 스레드는 한 번에 4틱을 사용할 수 있습니다.
- 이번 과제의 핵심인, 타이머 값을 다시 계산하고 타이머 대기 중인 스레드를 블록 상태에서 대기 상태로 변경하는 것은 timer_interrupt 또는 thread_tick에서 수행할 수 있을 것입니다.
- 틱을 다루기 위하여 int64_t 자료형을 사용하며, 틱이 증가하는 속도에 비해 최댓값이 매우 크므로 오버플로되지 않을 것으로 생각할 수 있습니다.

## 3. 해결 과정
1. 각 스레드가 만약 타이머 대기 중인 경우 스레드가 다시 복귀될 틱을 저장하는 변수를 wakeup_tick이라 하고, 스레드 구조체에 추가합니다.
1. 타이머 잠자기 상태에 있는 스레드들을 관리하기 위한 리스트를 전역으로 선언합니다. 리스트 초기화 코드를 추가합니다.
1. 타이머 잠자기 상태에 있는 스레드들 중에서 가장 빠르게 복귀 시기가 도래하는 스레드의 복귀 틱을 저장할 변수 하나를 전역으로 선언합니다. 이것을 이용하여 매 틱마다 잠자기 리스트 전체를 살펴보는 일이 없도록 합니다. next_time_to_awake로 명명합니다. next_time_to_awake의 값 관리와 관련된 함수를 구현합니다.
1. thread_sleep 함수를 구현합니다. 이 함수는 실행 중인 스레드가 블록된 다음 주어진 틱 이후부터 다시 스케줄되도록 합니다. next_time_to_awake를 갱신합니다.
1. time_sleep 함수가 바쁜 대기 대신 thread_sleep을 사용하도록 변경을 가합니다.
1. thread_awake 함수를 구현합니다. 이 함수는 타이머 대기 리스트를 살펴보면서, 복귀 시기를 맞이한 모든 스레드의 상태를 블록된 상태에서 대기 상태로 변경하는 작업, 그리고 next_time_to_awake를 최신 상태로 유지하는 작업을 수행합니다. 대기 상태로 변경된 스레드들은 스케줄러에 의해 미래에 선택될 것입니다. 시스템 상황에 따라서 처음에 지정한 대기 틱보다 많은 틱이 흐른 이후에 스레드가 선택될 수 있습니다. 이것은 사양에 부합하는 동작입니다.
1. timer_interrupt가 thread_awake 함수를, next_time_to_awake에 따라서 반드시 필요한 경우에만 호출하도록 합니다.

## 4. 결과
- 실습 자료에 나온 alarm-multiple을 실행했을 때, 개선 전에는 0 idle ticks, 939 kernel ticks를 사용한 반면, 개선 후에는 550 idle ticks, 390 kernel ticks를 사용합니다. 프로세스가 CPU를 사용한 틱의 수가 두 배 이상 줄어들었습니다.
- 변경 후에도 여전히 userprog의 모든 테스트를 통과합니다.

## 5. 참조
운영체제 및 시스템 프로그래밍 실습 자료와 Pintos 문서를 참조하였습니다.